\section{}
\paragraph{}\label{answer:12}
فراخوانی تابع \lr{\texttt{operator =}} یک پارامتر از نوع \lr{\texttt{data\_holder}} می‌گیرد. این نوع پارامتر، یک پارامتر فراخوانی با مقدار است، لذا تابع سازنده کپی فراخوانی می‌شود. برنامه‌نویسی که تابع سازنده کپی را می‌نوشت، تصمیم گرفت که میانبر بزند و از عملگر \lr{\texttt{=}} برای انجام کپی استفاده کند. لذا \lr{\texttt{operator =}} تابع سازنده کپی را فراخوانی می‌کند که به نوبهٔ خود، \lr{\texttt{operator =}}  را فراخوانی می‌کند که این هم دوباره تابع سازنده کپی را فراخوانی می‌کند... و این حلقه آن قدر ادامه پیدا می‌کند تا پُشته پر شود.

تابع \lr{\texttt{operator =}}  باید یک ارجاع ثابت را به عنوان نوع پارامتر خود بگیرد:
\begin{LTR}
    %@formatter:off
    \begin{lstlisting}[style=C++Style]
        data_holder &operator = (const data_holder &old_data_holder) {
    \end{lstlisting}
    %@formatter:on
\end{LTR}
همچنین باید یک ارجاع را برگرداند.

در موقع ارسال پارامترها، تا حد امکان از ارجاع‌های \lr{\texttt{const}} استفاده کنید. این کار از هزینهٔ اضافیِ انجام دادن یک کپی توسط یک پارامتر فراخوانی با مقدار جلوگیری می‌کند.