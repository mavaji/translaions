\section{}
\paragraph{}\label{answer:24}
این یک مسألهٔ بن‌بست کلاسیک است:
پردازهٔ 1 به منابع \lr{\texttt{\#1, \#2}} نیاز دارد.
پردازهٔ 2 به منابع \lr{\texttt{\#2, \#1}} نیاز دارد.

آنها این منابع را به آن ترتیب می‌گیرند. به یاد داشته باشید که سوئیچ بین ریسمان‌ها در هر زمانی می‌تواند رخ دهد. بنابراین یک شرایط مسابقه داریم که ممکن است این اتفاقات در آن بیفتد:
\begin{enumerate}
    \item پردازهٔ 1، منبع \lr{\texttt{\#1}} را بگیرد.
    \item به پردازهٔ 2 سوئیچ شود.
    \item پردازهٔ 2، منبع \lr{\texttt{\#2}} را بگیرد.
    \item پردازهٔ 2 سعی کند تا منبع \lr{\texttt{\#1}} را بگیرد.
    \item منبع \lr{\texttt{\#1}} در دسترس نیست، لذا پردازه به خواب می‌رود تا زمانی که آن منبع آزاد شود (و در این مدت، منبع \lr{\texttt{\#2}} را قفل‌کرده در اختیار دارد)
    \item به پردازهٔ 1 سوئیچ شود.
    \item پردازهٔ 1 سعی کند تا منبع \lr{\texttt{\#2}} را بگیرد. این منبع قفل است، لذا پردازه به خواب می‌رود تا زمانی که آن منبع آزاد شود (و در این مدت منبع \lr{\texttt{\#1}} را قفل‌کرده در اختیار دارد)
\end{enumerate}

نتیجه این است که پردازهٔ 1 در حالی که منبع \lr{\texttt{\#1}} را در اختیار دارد، منتظر منبع \lr{\texttt{\#2}} است و تا زمانی که منبع \lr{\texttt{\#2}} را به دست نیاورد، منبع \lr{\texttt{\#1}} را رها نمی‌کند. پردازهٔ 2 در حالی که منبع \lr{\texttt{\#2}} را در اختیار دارد، منتظر منبع \lr{\texttt{\#1}} است و تا زمانی که منبع \lr{\texttt{\#1}} را به دست نیاورد، منبع \lr{\texttt{\#2}} را رها نمی‌کند.

ترتیب قفل‌شدن‌ها را تعریف کنید. مثلاً باید به ترتیب \lr{\texttt{\#1, \#2}} قفل کنید. همیشه وقتی چند قفل وجود دارد، این ترتیب را رعایت کنید. وقتی چند قفل دارید، از این الگوریتم استفاده کنید:
\begin{enumerate}
    \item سعی کنید همهٔ قفل‌ها را بگیرید (اگر در دسترس نیستند، متوقف نشوید).
    \item اگر همه را گرفتید، کارِ خود را شروع کنید.
    \item اگر همهٔ قفل‌ها را نگرفتید، آنهایی را که نگرفتید، آزاد کنید، مدت زمانی به خواب روید و دوباره شروع کنید.
\end{enumerate}
